<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Hand Blocks</title>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;500&display=swap');

        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(circle at center, #1b2735 0%, #090a0f 100%);
            color: white;
            font-family: 'Roboto', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        .game-wrapper {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        /* –í–∏–¥–µ–æ —Å–∫—Ä—ã—Ç–æ —Å–∏–ª—å–Ω–µ–µ, —á—Ç–æ–±—ã –Ω–µ –æ—Ç–≤–ª–µ–∫–∞—Ç—å */
        #input_video {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.05; /* –ï–¥–≤–∞ –∑–∞–º–µ—Ç–Ω–æ */
            z-index: 0;
            pointer-events: none;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 10;
        }

        /* UI –°–ª–æ–π */
        .ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 20;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px 25px;
            border-radius: 15px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        h1 {
            margin: 0;
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            color: #00d2ff;
            text-shadow: 0 0 10px rgba(0, 210, 255, 0.5);
            letter-spacing: 2px;
        }

        .score-label {
            font-size: 14px;
            color: #aaa;
            text-transform: uppercase;
        }

        .score-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 36px;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        /* –ü–æ–¥—Å–∫–∞–∑–∫–∞ –≤–Ω–∏–∑—É */
        .hint-bar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            padding: 10px 30px;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 15px;
            pointer-events: none;
        }

        .hint-icon {
            font-size: 24px;
        }

        .hint-text {
            font-size: 14px;
            color: #ddd;
        }

        /* –≠–∫—Ä–∞–Ω –∑–∞–≥—Ä—É–∑–∫–∏ */
        #loading {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #090a0f;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s;
        }

        .loader {
            width: 50px; height: 50px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid #00d2ff;
            border-radius: 50%;
            animation: spin 1s cubic-bezier(0.4, 0, 0.2, 1) infinite;
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.2);
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* Game Over */
        #game-over {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            z-index: 50;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .go-content {
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid #333;
            padding: 40px 60px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 0 50px rgba(255, 68, 68, 0.2);
        }

        button {
            background: linear-gradient(45deg, #00d2ff, #007bff);
            border: none;
            padding: 12px 30px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 25px;
            transition: transform 0.2s, box-shadow 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.5);
        }

    </style>

    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        <div class="loader"></div>
        <p style="margin-top: 20px; color: #666; font-size: 12px; letter-spacing: 2px;">–ó–ê–ì–†–£–ó–ö–ê –ò–ò...</p>
    </div>

    <div class="game-wrapper">
        <video id="input_video" playsinline></video>
        <canvas id="game_canvas"></canvas>
        
        <div class="ui-layer">
            <div class="glass-panel">
                <h1>NEON BLOCKS</h1>
                <div style="margin-top: 10px;">
                    <div class="score-label">–°–ß–ï–¢</div>
                    <div class="score-value" id="score">0</div>
                </div>
            </div>
        </div>

        <div id="game-over">
            <div class="go-content">
                <h1 style="color: #ff4444; font-size: 42px;">GAME OVER</h1>
                <p style="color: #aaa; margin-top: 10px;">–§–ò–ù–ê–õ–¨–ù–´–ô –°–ß–ï–¢</p>
                <div class="score-value" id="final-score" style="font-size: 48px;">0</div>
                <button onclick="restartGame()">–ò–ì–†–ê–¢–¨ –°–ù–û–í–ê</button>
            </div>
        </div>

        <div class="hint-bar">
            <span class="hint-icon">üëå</span>
            <span class="hint-text"><b>–©–∏–ø–æ–∫</b> —á—Ç–æ–±—ã –≤–∑—è—Ç—å | –†–∞–∑–∂–∞—Ç—å —á—Ç–æ–±—ã –±—Ä–æ—Å–∏—Ç—å</span>
        </div>
    </div>

    <script>
        // ==========================================
        // –ù–ê–°–¢–†–û–ô–ö–ò
        // ==========================================
        const CONFIG = {
            gridSize: 8,
            gap: 6,            // –ß—É—Ç—å –±–æ–ª—å—à–µ –æ—Ç—Å—Ç—É–ø –¥–ª—è –∫—Ä–∞—Å–æ—Ç—ã
            pinchThreshold: 0.05,
            smoothFactor: 0.25, // –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è (–º–µ–Ω—å—à–µ = –ø–ª–∞–≤–Ω–µ–µ, –Ω–æ –±–æ–ª—å—à–µ –∑–∞–¥–µ—Ä–∂–∫–∞)
            dragOffsetY: 80,    // –°–º–µ—â–µ–Ω–∏–µ –±–ª–æ–∫–∞ –≤–≤–µ—Ä—Ö –ø—Ä–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–∏ (—á—Ç–æ–±—ã –ø–∞–ª–µ—Ü –Ω–µ –∑–∞–∫—Ä—ã–≤–∞–ª)
            pickupCooldownFrames: 10, // –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ —Ç–µ–º –∫–∞–∫ –º–æ–∂–Ω–æ –±—Ä–æ—Å–∏—Ç—å (–∑–∞—â–∏—Ç–∞ –æ—Ç –¥—Ä–æ–∂–∞–Ω–∏—è)
            colors: {
                gridBase: 'rgba(255, 255, 255, 0.03)',
                gridBorder: 'rgba(255, 255, 255, 0.05)',
                shapes: [
                    '#FF0055', // Neon Red
                    '#00FF99', // Neon Green
                    '#00D2FF', // Neon Blue
                    '#FFD700', // Gold
                    '#BD00FF', // Purple
                    '#FF8800'  // Orange
                ]
            }
        };

        const canvas = document.getElementById('game_canvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const finalScoreEl = document.getElementById('final-score');
        const gameOverEl = document.getElementById('game-over');
        const loadingEl = document.getElementById('loading');

        // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
        let width, height;
        let grid = [];
        let particles = [];
        let spawnBlocks = [];
        let score = 0;
        let isGameOver = false;
        let cellSize = 0;

        // –†—É–∫–∞ (—Å –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–µ–π)
        let hand = {
            rawX: 0, rawY: 0, // –°—ã—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç –º–æ–¥–µ–ª–∏
            x: 0, y: 0,       // –°–≥–ª–∞–∂–µ–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
            pinching: false,
            pinchDist: 0,     // –î–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–∏–ª—ã –Ω–∞–∂–∞—Ç–∏—è
            active: false,
            lossTimer: 0      // –¢–∞–π–º–µ—Ä –ø–æ—Ç–µ—Ä–∏ —Ä—É–∫–∏ (–¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç –º–∏–≥–∞–Ω–∏—è)
        };

        let heldBlock = null;
        let pickupTimer = 0; // –¢–∞–π–º–µ—Ä –ø–æ—Å–ª–µ –≤–∑—è—Ç–∏—è –±–ª–æ–∫–∞

        // –§–∏–≥—É—Ä—ã
        const SHAPES = [
            [[1]], [[1,1]], [[1,1,1]], [[1,1,1,1]], // –õ–∏–Ω–∏–∏
            [[1,1],[1,1]], // –ö–≤–∞–¥—Ä–∞—Ç
            [[1,0],[1,0],[1,1]], [[0,1],[0,1],[1,1]], // L-–æ–±—Ä–∞–∑–Ω—ã–µ
            [[1,1,1],[0,1,0]], // T
            [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]] // Z-–æ–±—Ä–∞–∑–Ω—ã–µ
        ];

        // ==========================================
        // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
        // ==========================================
        function init() {
            resize();
            createGrid();
            spawnNewBlocks();
            loop();
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            
            // –†–∞—Å—á–µ—Ç —Ä–∞–∑–º–µ—Ä–∞ –∫–ª–µ—Ç–∫–∏ (–º–∞–∫—Å 600px –ø–æ–ª–µ –∏–ª–∏ 90% —à–∏—Ä–∏–Ω—ã —ç–∫—Ä–∞–Ω–∞ –Ω–∞ –º–æ–±–∏–ª–∫–∞—Ö)
            const minDim = Math.min(width, height * 0.75); // –û—Å—Ç–∞–≤–ª—è–µ–º –º–µ—Å—Ç–æ —Å–Ω–∏–∑—É –¥–ª—è —Å–ø–∞–≤–Ω–∞
            const fieldSize = Math.min(600, minDim - 40);
            cellSize = (fieldSize - (CONFIG.gridSize * CONFIG.gap)) / CONFIG.gridSize;
        }
        window.addEventListener('resize', resize);

        function createGrid() {
            grid = Array(CONFIG.gridSize).fill().map(() => Array(CONFIG.gridSize).fill(null));
        }

        // ==========================================
        // –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò
        // ==========================================
        function lerp(start, end, t) {
            return start * (1 - t) + end * t;
        }

        function spawnNewBlocks() {
            spawnBlocks = [];
            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º —Å–ø–∞–≤–Ω-–±–ª–æ–∫–∏ —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ –≤–Ω–∏–∑—É —ç–∫—Ä–∞–Ω–∞
            const zoneWidth = width / 3;
            const yPos = height - (height * 0.15); // 15% –æ—Ç –Ω–∏–∑–∞

            for (let i = 0; i < 3; i++) {
                const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                const color = CONFIG.colors.shapes[Math.floor(Math.random() * CONFIG.colors.shapes.length)];
                
                spawnBlocks.push({
                    shape: shape,
                    color: color,
                    baseX: zoneWidth * i + zoneWidth / 2,
                    baseY: yPos,
                    x: zoneWidth * i + zoneWidth / 2,
                    y: yPos + 100, // –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ—è–≤–ª–µ–Ω–∏—è —Å–Ω–∏–∑—É
                    scale: 0.55,
                    dragging: false,
                    targetY: yPos, // –î–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ –≤—Ö–æ–¥–∞
                    id: Math.random()
                });
            }
            checkGameOver();
        }

        function restartGame() {
            score = 0;
            scoreEl.innerText = 0;
            createGrid();
            spawnNewBlocks();
            isGameOver = false;
            gameOverEl.style.display = 'none'; // Flex —Å—Ç–∞–≤–∏—Ç—Å—è –≤ CSS –∫–ª–∞—Å—Å–∞
        }

        // ==========================================
        // –õ–û–ì–ò–ö–ê –ò–ì–†–´
        // ==========================================
        function checkGameOver() {
            // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å–ª–∏ –Ω–∏ –æ–¥–∏–Ω –±–ª–æ–∫ –∏–∑ —Å–ø–∞–≤–Ω–∞ –Ω–µ –ª–µ–∑–µ—Ç –Ω–∞ –ø–æ–ª–µ - –∫–æ–Ω–µ—Ü
            let canPlaceAny = false;
            if (spawnBlocks.length === 0) return; // –ï—Å–ª–∏ –ø—É—Å—Ç–æ, —Å–∫–æ—Ä–æ –∑–∞—Å–ø–∞–≤–Ω—è—Ç—Å—è

            for (let block of spawnBlocks) {
                if (canBlockFit(block)) {
                    canPlaceAny = true;
                    break;
                }
            }

            if (!canPlaceAny) {
                isGameOver = true;
                finalScoreEl.innerText = score;
                gameOverEl.style.display = 'flex';
            }
        }

        function canBlockFit(block) {
            for (let r = 0; r < CONFIG.gridSize; r++) {
                for (let c = 0; c < CONFIG.gridSize; c++) {
                    if (checkPlacement(block.shape, r, c)) return true;
                }
            }
            return false;
        }

        function checkPlacement(shape, row, col) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        if (row + r >= CONFIG.gridSize || col + c >= CONFIG.gridSize || grid[row + r][col + c]) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function placeBlock(block, row, col) {
            for (let r = 0; r < block.shape.length; r++) {
                for (let c = 0; c < block.shape[r].length; c++) {
                    if (block.shape[r][c]) {
                        grid[row + r][col + c] = block.color;
                    }
                }
            }
            score += 10;
            checkLines();
        }

        function checkLines() {
            let lines = [];
            let columns = [];

            // –ò—â–µ–º –ø–æ–ª–Ω—ã–µ –ª–∏–Ω–∏–∏
            for (let r = 0; r < CONFIG.gridSize; r++) {
                if (grid[r].every(c => c !== null)) lines.push(r);
            }
            for (let c = 0; c < CONFIG.gridSize; c++) {
                let full = true;
                for (let r = 0; r < CONFIG.gridSize; r++) if (!grid[r][c]) full = false;
                if (full) columns.push(c);
            }

            // –û—á–∏—Å—Ç–∫–∞ –∏ —ç—Ñ—Ñ–µ–∫—Ç—ã
            if (lines.length > 0 || columns.length > 0) {
                const totalCleared = lines.length + columns.length;
                score += totalCleared * 100 * totalCleared; // –ö–æ–º–±–æ –º–Ω–æ–∂–∏—Ç–µ–ª—å

                lines.forEach(r => {
                    grid[r].fill(null);
                    createExplosion(0, r, true);
                });
                columns.forEach(c => {
                    for (let r = 0; r < CONFIG.gridSize; r++) grid[r][c] = null;
                    createExplosion(c, 0, false);
                });
            }
            
            scoreEl.innerText = score;
        }

        // ==========================================
        // –≠–§–§–ï–ö–¢–´
        // ==========================================
        function createExplosion(idx, idy, isRow) {
            const fieldW = CONFIG.gridSize * (cellSize + CONFIG.gap);
            const startX = (width - fieldW) / 2;
            const startY = (height - fieldW) / 2 - 50;

            for (let i = 0; i < CONFIG.gridSize; i++) {
                let x, y;
                if (isRow) {
                    x = startX + i * (cellSize + CONFIG.gap) + cellSize/2;
                    y = startY + idy * (cellSize + CONFIG.gap) + cellSize/2;
                } else {
                    x = startX + idx * (cellSize + CONFIG.gap) + cellSize/2;
                    y = startY + i * (cellSize + CONFIG.gap) + cellSize/2;
                }

                // –í–∑—Ä—ã–≤ —á–∞—Å—Ç–∏—Ü
                for(let k=0; k<3; k++) {
                    particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 15,
                        vy: (Math.random() - 0.5) * 15,
                        life: 1.0,
                        color: '#fff',
                        size: Math.random() * 4 + 2
                    });
                }
            }
        }

        // ==========================================
        // UPDATE (–õ–æ–≥–∏–∫–∞ –∫–∞–¥—Ä–∞)
        // ==========================================
        function update() {
            if (isGameOver) return;
            
            // –¢–∞–π–º–µ—Ä –∫—É–ª–¥–∞—É–Ω–∞ –ø–æ—Å–ª–µ –≤–∑—è—Ç–∏—è
            if (pickupTimer > 0) pickupTimer--;

            // 1. –°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è —Ä—É–∫–∏
            if (hand.active) {
                hand.x = lerp(hand.x, hand.rawX, CONFIG.smoothFactor);
                hand.y = lerp(hand.y, hand.rawY, CONFIG.smoothFactor);
            }

            // 2. –ê–Ω–∏–º–∞—Ü–∏—è –±–ª–æ–∫–æ–≤ –≤ —Å–ø–∞–≤–Ω–µ
            spawnBlocks.forEach(b => {
                if (!b.dragging) {
                    // –ü–ª–∞–≤–Ω—ã–π –≤–æ–∑–≤—Ä–∞—Ç –Ω–∞ –±–∞–∑—É
                    b.x = lerp(b.x, b.baseX, 0.15);
                    b.y = lerp(b.y, b.baseY, 0.15); // –í–æ–∑–≤—Ä–∞—Ç –∫ baseY (–∏–ª–∏ targetY –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ)
                    b.scale = lerp(b.scale, 0.55, 0.15);
                }
            });

            // 3. –õ–æ–≥–∏–∫–∞ –∑–∞—Ö–≤–∞—Ç–∞
            if (hand.active) {
                if (!heldBlock && hand.pinching) {
                    // –ü—ã—Ç–∞–µ–º—Å—è –≤–∑—è—Ç—å –±–ª–æ–∫
                    for (let i = 0; i < spawnBlocks.length; i++) {
                        const b = spawnBlocks[i];
                        const dist = Math.hypot(hand.x - b.x, hand.y - b.y);
                        if (dist < 80) { // –†–∞–¥–∏—É—Å –∑–∞—Ö–≤–∞—Ç–∞
                            heldBlock = b;
                            heldBlock.dragging = true;
                            spawnBlocks.splice(i, 1);
                            pickupTimer = CONFIG.pickupCooldownFrames; // –°—Ç–∞–≤–∏–º –∑–∞—â–∏—Ç—É –æ—Ç –º–≥–Ω–æ–≤–µ–Ω–Ω–æ–≥–æ —Å–±—Ä–æ—Å–∞
                            break;
                        }
                    }
                } else if (heldBlock) {
                    // –î–µ—Ä–∂–∏–º –±–ª–æ–∫, –µ—Å–ª–∏ —â–∏–ø–æ–∫ –∞–∫—Ç–∏–≤–µ–Ω –ò–õ–ò —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–∞–π–º–µ—Ä –∑–∞—â–∏—Ç—ã (–¥–∞–∂–µ –µ—Å–ª–∏ —â–∏–ø–æ–∫ –ø—Ä–æ–ø–∞–ª –Ω–∞ –º–∏–≥)
                    if (hand.pinching || pickupTimer > 0) {
                        // –¢–∞—â–∏–º
                        // –î–æ–±–∞–≤–ª—è–µ–º offset –ø–æ Y, —á—Ç–æ–±—ã –ø–∞–ª–µ—Ü –Ω–µ –∑–∞–∫—Ä—ã–≤–∞–ª –±–ª–æ–∫
                        const targetX = hand.x;
                        const targetY = hand.y - CONFIG.dragOffsetY; 
                        
                        heldBlock.x = lerp(heldBlock.x, targetX, 0.4);
                        heldBlock.y = lerp(heldBlock.y, targetY, 0.4);
                        heldBlock.scale = lerp(heldBlock.scale, 1.0, 0.2); // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –¥–æ 100%
                    } else {
                        // –ë—Ä–æ—Å–∞–µ–º
                        const fieldW = CONFIG.gridSize * (cellSize + CONFIG.gap);
                        const startX = (width - fieldW) / 2;
                        const startY = (height - fieldW) / 2 - 50;

                        // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º
                        const blockW = heldBlock.shape[0].length * cellSize;
                        const blockH = heldBlock.shape.length * cellSize;
                        const testX = heldBlock.x - blockW/2;
                        const testY = heldBlock.y - blockH/2;

                        const col = Math.round((testX - startX) / (cellSize + CONFIG.gap));
                        const row = Math.round((testY - startY) / (cellSize + CONFIG.gap));

                        if (checkPlacement(heldBlock.shape, row, col)) {
                            placeBlock(heldBlock, row, col);
                            heldBlock = null;
                            if (spawnBlocks.length === 0) spawnNewBlocks();
                            else checkGameOver();
                        } else {
                            // –í–æ–∑–≤—Ä–∞—Ç
                            heldBlock.dragging = false;
                            spawnBlocks.push(heldBlock);
                            heldBlock = null;
                        }
                    }
                }
            }

            // 4. –ß–∞—Å—Ç–∏—Ü—ã
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.04;
                p.vy += 0.5; // –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        // ==========================================
        // RENDER (–û—Ç—Ä–∏—Å–æ–≤–∫–∞)
        // ==========================================
        function draw() {
            ctx.clearRect(0, 0, width, height);

            const fieldW = CONFIG.gridSize * (cellSize + CONFIG.gap);
            const startX = (width - fieldW) / 2;
            const startY = (height - fieldW) / 2 - 50;

            // 1. –°–µ—Ç–∫–∞ (–§–æ–Ω)
            for (let r = 0; r < CONFIG.gridSize; r++) {
                for (let c = 0; c < CONFIG.gridSize; c++) {
                    const x = startX + c * (cellSize + CONFIG.gap);
                    const y = startY + r * (cellSize + CONFIG.gap);
                    
                    // –°—Ç–∏–ª—å –ø—É—Å—Ç–æ–π –∫–ª–µ—Ç–∫–∏
                    ctx.fillStyle = CONFIG.colors.gridBase;
                    ctx.strokeStyle = CONFIG.colors.gridBorder;
                    ctx.lineWidth = 1;
                    
                    ctx.beginPath();
                    ctx.roundRect(x, y, cellSize, cellSize, 8);
                    ctx.fill();
                    ctx.stroke();

                    // –ó–∞–ø–æ–ª–Ω–µ–Ω–Ω–∞—è –∫–ª–µ—Ç–∫–∞
                    if (grid[r][c]) {
                        drawNeonBlock(x, y, cellSize, grid[r][c]);
                    }
                }
            }

            // 2. –ë–ª–æ–∫–∏ –≤ —Å–ø–∞–≤–Ω–µ
            spawnBlocks.forEach(b => drawBlock(b, b.x, b.y, b.scale, 1));

            // 3. –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º—ã–π –±–ª–æ–∫ + –ü—Ä–∏–∑—Ä–∞–∫
            if (heldBlock) {
                // –ü—Ä–∏–∑—Ä–∞–∫
                const blockW = heldBlock.shape[0].length * cellSize;
                const blockH = heldBlock.shape.length * cellSize;
                const testX = heldBlock.x - blockW/2;
                const testY = heldBlock.y - blockH/2;
                const col = Math.round((testX - startX) / (cellSize + CONFIG.gap));
                const row = Math.round((testY - startY) / (cellSize + CONFIG.gap));

                if (checkPlacement(heldBlock.shape, row, col)) {
                    ctx.globalAlpha = 0.3;
                    for(let r=0; r<heldBlock.shape.length; r++) {
                        for(let c=0; c<heldBlock.shape[r].length; c++) {
                            if(heldBlock.shape[r][c]) {
                                const gx = startX + (col+c)*(cellSize+CONFIG.gap);
                                const gy = startY + (row+r)*(cellSize+CONFIG.gap);
                                drawNeonBlock(gx, gy, cellSize, heldBlock.color);
                            }
                        }
                    }
                    ctx.globalAlpha = 1.0;
                }
                
                // –°–∞–º –±–ª–æ–∫
                drawBlock(heldBlock, heldBlock.x, heldBlock.y, heldBlock.scale, 1);
            }

            // 4. –ß–∞—Å—Ç–∏—Ü—ã
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            // 5. –ö—É—Ä—Å–æ—Ä
            if (hand.active) {
                drawCursor();
            }
        }

        function drawNeonBlock(x, y, size, color) {
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = 15;
            
            ctx.beginPath();
            ctx.roundRect(x, y, size, size, 6);
            ctx.fill();
            
            // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –±–ª–∏–∫
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.roundRect(x+2, y+2, size-4, size-4, 4);
            ctx.fill();
        }

        function drawBlock(block, cx, cy, scale, alpha) {
            const cellS = cellSize * scale;
            const gapS = CONFIG.gap * scale;
            const w = block.shape[0].length * (cellS + gapS);
            const h = block.shape.length * (cellS + gapS);
            
            const sx = cx - w/2;
            const sy = cy - h/2;

            for(let r=0; r<block.shape.length; r++) {
                for(let c=0; c<block.shape[r].length; c++) {
                    if(block.shape[r][c]) {
                        drawNeonBlock(sx + c*(cellS+gapS), sy + r*(cellS+gapS), cellS, block.color);
                    }
                }
            }
        }

        function drawCursor() {
            const x = hand.x;
            const y = hand.y;
            
            // –ö—Ä—É–≥ –∫—É—Ä—Å–æ—Ä–∞
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00d2ff';
            ctx.strokeStyle = '#00d2ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, 15, 0, Math.PI*2);
            ctx.stroke();

            // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–∞–∂–∞—Ç–∏—è (–∑–∞–ø–æ–ª–Ω—è–µ—Ç—Å—è)
            if (hand.pinching) {
                ctx.fillStyle = '#00d2ff';
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI*2);
                ctx.fill();
                
                // –õ–∏–Ω–∏—è –∫ –±–ª–æ–∫—É (–≤–µ—Ä–µ–≤–æ—á–∫–∞), –µ—Å–ª–∏ –¥–µ—Ä–∂–∏–º
                if (heldBlock) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(heldBlock.x, heldBlock.y);
                    ctx.strokeStyle = 'rgba(0, 210, 255, 0.3)';
                    ctx.stroke();
                }
            }
            
            ctx.shadowBlur = 0;
        }

        // ==========================================
        // MEDIAPIPE LOGIC
        // ==========================================
        function onResults(results) {
            loadingEl.style.opacity = 0;
            setTimeout(() => loadingEl.style.display = 'none', 500);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                hand.lossTimer = 0; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–∞–π–º–µ—Ä –ø–æ—Ç–µ—Ä–∏
                hand.active = true;
                const lm = results.multiHandLandmarks[0];
                const index = lm[8];
                const thumb = lm[4];

                // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–µ–ª–µ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã (–∑–µ—Ä–∫–∞–ª—å–Ω–æ)
                hand.rawX = (1 - index.x) * width;
                hand.rawY = index.y * height;

                // –ï–≤–∫–ª–∏–¥–æ–≤–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ (–±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω–æ)
                const aspect = width / height;
                const dx = ((1 - index.x) - (1 - thumb.x)) * aspect; 
                const dy = index.y - thumb.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                hand.pinchDist = dist;
                hand.pinching = dist < CONFIG.pinchThreshold;
                
            } else {
                // –ï—Å–ª–∏ —Ä—É–∫–∞ –ø–æ—Ç–µ—Ä—è–Ω–∞, –∑–∞–ø—É—Å–∫–∞–µ–º "Grace Period" (—Ç–∞–π–º–µ—Ä –º–∏–ª–æ—Å–µ—Ä–¥–∏—è)
                // –ù–µ –±—Ä–æ—Å–∞–µ–º –±–ª–æ–∫ —Å—Ä–∞–∑—É, –∂–¥–µ–º –æ–∫–æ–ª–æ 15 –∫–∞–¥—Ä–æ–≤ (~0.5 —Å–µ–∫)
                hand.lossTimer++;
                if (hand.lossTimer > 15) {
                    hand.active = false;
                    hand.pinching = false;
                    
                    // –ï—Å–ª–∏ —Ä—É–∫–∞ —Ä–µ–∞–ª—å–Ω–æ –ø–æ—Ç–µ—Ä—è–Ω–∞ –Ω–∞–¥–æ–ª–≥–æ, –±—Ä–æ—Å–∞–µ–º –±–ª–æ–∫
                    if (heldBlock) {
                        heldBlock.dragging = false;
                        spawnBlocks.push(heldBlock);
                        heldBlock = null;
                    }
                }
                // –ï—Å–ª–∏ –º–µ–Ω—å—à–µ 15 –∫–∞–¥—Ä–æ–≤, –º—ã –ø—Ä–æ—Å—Ç–æ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º.
                // –ë–ª–æ–∫ –∑–∞–≤–∏—Å–Ω–µ—Ç –≤ –≤–æ–∑–¥—É—Ö–µ (–≤ –ø–æ—Å–ª–µ–¥–Ω–µ–π –ø–æ–∑–∏—Ü–∏–∏ update()),
                // —á—Ç–æ –≤–∏–∑—É–∞–ª—å–Ω–æ –ª—É—á—à–µ, —á–µ–º –µ–≥–æ –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ.
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });
        hands.onResults(onResults);

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞–º–µ—Ä—ã —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ–º
        const camera = new Camera(document.getElementById('input_video'), {
            onFrame: async () => await hands.send({image: document.getElementById('input_video')}),
            width: 1280,
            height: 720
        });
        camera.start();

        // Loop
        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        init();

    </script>
</body>
</html>
